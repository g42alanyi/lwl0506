<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>è±ªè¯ 1.5è¬ç²’å­ 3D é‡‘å±¬è–èª•æ¨¹</title>
    <style>
        @font-face {
            font-family: 'Noto Serif TC';
            src: url('https://fonts.gstatic.com/s/notoseriftc/v19/XLYgR5vtWpzzTfPR--iJ_y2W4k_B3N-Y76kP_D_A7_N.woff2') format('woff2');
        }
        body { margin: 0; overflow: hidden; background: #020205; }
        #instructions {
            position: absolute; top: 30px; width: 100%; text-align: center;
            color: #f1d37e; font-size: 36px; pointer-events: none; 
            text-shadow: 0 0 20px rgba(212,175,55,0.8);
            font-family: 'Noto Serif TC', serif;
            letter-spacing: 4px;
        }
        #audio-hint {
            position: absolute; bottom: 20px; left: 20px; color: #fff; cursor: pointer;
            border: 1px solid #d4af37; padding: 12px 20px; border-radius: 30px;
            background: rgba(212,175,55,0.1);
            font-family: 'Noto Serif TC', serif;
            transition: all 0.3s;
            z-index: 100;
            backdrop-filter: blur(5px);
        }
        #audio-hint:hover { background: rgba(212,175,55,0.3); transform: scale(1.05); }
    </style>
</head>
<body>

<div id="instructions">âœ¨ éµéµ è–èª•å¿«æ¨‚ âœ¨</div>
<div id="audio-hint" onclick="playMusic()">ğŸµ é–‹å•ŸéŸ³æ¨‚èˆ‡å¥‡è¹Ÿæ™‚åˆ»</div>

<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import gsap from 'https://cdn.skypack.dev/gsap';

// --- å ´æ™¯åˆå§‹åŒ– ---
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x020205, 0.015);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.2;
document.body.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);
camera.position.set(0, 15, 40);
controls.enableDamping = true;
controls.autoRotate = false;

// --- ç‡ˆå…‰å„ªåŒ– (å¼·åŒ–åå…‰æ„Ÿ) ---
const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
scene.add(ambientLight);

const mainLight = new THREE.SpotLight(0xffffff, 1000);
mainLight.position.set(20, 40, 20);
mainLight.angle = 0.5;
scene.add(mainLight);

const colorLight1 = new THREE.PointLight(0xd4af37, 500); // é‡‘å…‰
colorLight1.position.set(-15, 10, 15);
scene.add(colorLight1);

const colorLight2 = new THREE.PointLight(0xff0000, 300); // ç´…å…‰
colorLight2.position.set(15, 5, -15);
scene.add(colorLight2);

// --- è–èª•æ¨¹ (15,000 ç²’å­) ---
const INSTANCE_COUNT = 15000; 
const dummy = new THREE.Object3D();
let currentState = 'tree';

// æ··åˆæè³ªï¼šçƒé«”èˆ‡ç«‹æ–¹é«”
const goldMat = new THREE.MeshStandardMaterial({ 
    color: 0xD4AF37, metalness: 1, roughness: 0.15, 
    envMapIntensity: 1 
});

const sphereGeo = new THREE.SphereGeometry(0.12, 8, 8);
const boxGeo = new THREE.BoxGeometry(0.18, 0.18, 0.18);

// ç‚ºäº†è¦–è¦ºå¤šæ¨£æ€§ï¼Œæˆ‘å€‘å‰µå»ºå…©å€‹ InstancedMesh
const instSpheres = new THREE.InstancedMesh(sphereGeo, goldMat, INSTANCE_COUNT / 2);
const instBoxes = new THREE.InstancedMesh(boxGeo, goldMat, INSTANCE_COUNT / 2);
scene.add(instSpheres, instBoxes);

const treePos = [];
const textPos = [];

// ç”Ÿæˆæ¨¹çš„åº§æ¨™ (åˆ©ç”¨é»ƒé‡‘èºæ—‹èˆ‡éš¨æ©Ÿæ“¾å‹•)
function generateTreeLayout() {
    for (let i = 0; i < INSTANCE_COUNT; i++) {
        const ratio = i / INSTANCE_COUNT;
        const height = ratio * 25; // æ¨¹çš„é«˜åº¦
        const maxRadius = (1 - ratio) * 10; // åº•éƒ¨å¯¬
        
        // æ ¸å¿ƒåˆ†ä½ˆç®—æ³•ï¼šè®“ä¸­å¿ƒæ›´åšå¯¦
        const angle = i * 0.15;
        const dist = Math.sqrt(Math.random()) * maxRadius; 
        const x = Math.cos(angle) * dist;
        const z = Math.sin(angle) * dist;
        const y = height - 8;

        const pos = new THREE.Vector3(x, y, z);
        treePos.push(pos);

        // éš¨æ©Ÿé¡è‰²åˆ†ä½ˆ
        const color = new THREE.Color();
        const rand = Math.random();
        if (rand < 0.5) color.setHex(0xD4AF37); // åœŸè±ªé‡‘
        else if (rand < 0.8) color.setHex(0xB22222); // æ·±ç´…å¯¶çŸ³
        else color.setHex(0x006400); // è–èª•ç¶ 

        const targetMesh = (i < INSTANCE_COUNT/2) ? instSpheres : instBoxes;
        const localIdx = i % (INSTANCE_COUNT/2);
        targetMesh.setColorAt(localIdx, color);
    }
}
generateTreeLayout();

// --- æ–‡å­—åº§æ¨™ (åŠ å¼·å¯†åº¦) ---
function createTextPoints() {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = 1200; canvas.height = 300;
    ctx.fillStyle = 'white';
    ctx.font = 'bold 100px "Noto Serif TC", serif';
    ctx.textAlign = 'center';
    ctx.fillText('éµéµ è–èª•å¿«æ¨‚', 600, 150);
    
    const imgData = ctx.getImageData(0, 0, 1200, 300).data;
    const tempPts = [];
    for (let y = 0; y < 300; y += 3) { // æé«˜æ¡æ¨£ç‡
        for (let x = 0; x < 1200; x += 3) {
            if (imgData[(y * 1200 + x) * 4] > 150) {
                tempPts.push(new THREE.Vector3((x - 600) * 0.06, (150 - y) * 0.06 + 5, 0));
            }
        }
    }
    for (let i = 0; i < INSTANCE_COUNT; i++) {
        textPos.push(tempPts[i % tempPts.length].clone().add(new THREE.Vector3(
            (Math.random()-0.5)*0.1, (Math.random()-0.5)*0.1, (Math.random()-0.5)*0.1
        )));
    }
}
createTextPoints();

// --- æ¨¹é ‚å¤§æ˜Ÿ ---
const star = new THREE.Mesh(
    new THREE.OctahedronGeometry(1.5, 0), 
    new THREE.MeshStandardMaterial({ color: 0xFFFF00, emissive: 0xFFCC00, emissiveIntensity: 2 })
);
star.position.y = 17.5;
scene.add(star);

// --- æ©˜è²“ (ç²¾ç°¡ç‰ˆï¼Œé©åˆé«˜å¯†åº¦å ´æ™¯) ---
const cat = new THREE.Group();
const orangeMat = new THREE.MeshStandardMaterial({ color: 0xffa500 });
const body = new THREE.Mesh(new THREE.CapsuleGeometry(0.8, 1.2, 4, 8), orangeMat);
body.rotation.z = Math.PI/2;
cat.add(body);
const head = new THREE.Mesh(new THREE.SphereGeometry(0.7, 16, 16), orangeMat);
head.position.set(1.2, 0.6, 0);
cat.add(head);
cat.position.set(12, -7.5, 5);
cat.scale.set(1.5, 1.5, 1.5);
scene.add(cat);

// --- é›ªèŠ±ç²’å­ (10,000 é¡†) ---
const snowGeo = new THREE.BufferGeometry();
const snowBuf = new Float32Array(10000 * 3);
for(let i=0; i<30000; i++) snowBuf[i] = (Math.random()-0.5)*150;
snowGeo.setAttribute('position', new THREE.BufferAttribute(snowBuf, 3));
const snow = new THREE.Points(snowGeo, new THREE.PointsMaterial({ color: 0xffffff, size: 0.15, transparent: true, opacity: 0.6 }));
scene.add(snow);

// --- æ ¸å¿ƒå‹•ç•«åˆ‡æ› ---
function transition(targetArray) {
    const obj = { t: 0 };
    const startPositions = [];
    
    // ç´€éŒ„ç•¶å‰æ‰€æœ‰ä½ç½®
    [instSpheres, instBoxes].forEach(mesh => {
        for(let i=0; i<INSTANCE_COUNT/2; i++) {
            const m = new THREE.Matrix4();
            mesh.getMatrixAt(i, m);
            startPositions.push(new THREE.Vector3().setFromMatrixPosition(m));
        }
    });

    gsap.to(obj, {
        t: 1, duration: 2.5, ease: "expo.inOut",
        onUpdate: () => {
            for (let i = 0; i < INSTANCE_COUNT; i++) {
                const mesh = i < INSTANCE_COUNT/2 ? instSpheres : instBoxes;
                const idx = i % (INSTANCE_COUNT/2);
                dummy.position.lerpVectors(startPositions[i], targetArray[i], obj.t);
                if(currentState !== 'tree') dummy.rotation.y += 0.02; // æ•£é–‹æ™‚å¸¶é»è‡ªè½‰
                dummy.updateMatrix();
                mesh.setMatrixAt(idx, dummy.matrix);
            }
            instSpheres.instanceMatrix.needsUpdate = true;
            instBoxes.instanceMatrix.needsUpdate = true;
        }
    });
}

// --- äº¤äº’ç›£è½ ---
window.addEventListener('mousedown', () => {
    if (currentState === 'tree') {
        const scatter = treePos.map(p => p.clone().add(new THREE.Vector3((Math.random()-0.5)*40, (Math.random()-0.5)*40, (Math.random()-0.5)*40)));
        transition(scatter); currentState = 'scatter';
    } else if (currentState === 'scatter') {
        transition(textPos); currentState = 'text';
    } else {
        transition(treePos); currentState = 'tree';
    }
});

// --- æ¸²æŸ“è¿´åœˆ ---
function animate() {
    requestAnimationFrame(animate);
    
    if (currentState === 'tree') {
        instSpheres.rotation.y += 0.003;
        instBoxes.rotation.y += 0.003;
        star.rotation.y += 0.02;
    }

    // é›ªèŠ±ä¸‹è½
    const pos = snow.geometry.attributes.position.array;
    for(let i=1; i<pos.length; i+=3) {
        pos[i] -= 0.1;
        if(pos[i] < -20) pos[i] = 60;
    }
    snow.geometry.attributes.position.needsUpdate = true;

    controls.update();
    renderer.render(scene, camera);
}

// åˆå§‹åŒ–ä½ç½®
function initPositions() {
    for (let i = 0; i < INSTANCE_COUNT; i++) {
        const mesh = i < INSTANCE_COUNT/2 ? instSpheres : instBoxes;
        const idx = i % (INSTANCE_COUNT/2);
        dummy.position.copy(treePos[i]);
        dummy.updateMatrix();
        mesh.setMatrixAt(idx, dummy.matrix);
    }
}
initPositions();
animate();

// éŸ³æ¨‚è™•ç† (ç•¥ï¼ŒåŒå‰)
const sound = new THREE.Audio(new THREE.AudioListener());
window.playMusic = () => {
    if (!sound.isPlaying) {
        new THREE.AudioLoader().load('https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3', (buf) => {
            sound.setBuffer(buf); sound.setLoop(true); sound.setVolume(0.5); sound.play();
        });
        document.getElementById('audio-hint').style.display = 'none';
    }
};

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>

