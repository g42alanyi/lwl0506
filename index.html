<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>3D Metal Christmas Tree with Snow & Procedural Cat</title>
    <style>
        @font-face {
            font-family: 'Noto Serif TC';
            src: url('https://fonts.gstatic.com/s/notoseriftc/v19/XLYgR5vtWpzzTfPR--iJ_y2W4k_B3N-Y76kP_D_A7_N.woff2') format('woff2');
            font-weight: normal;
            font-style: normal;
        }
        body { margin: 0; overflow: hidden; background: #050505; }
        #instructions {
            position: absolute; top: 20px; width: 100%; text-align: center;
            color: #d4af37; font-size: 32px; pointer-events: none; text-shadow: 0 0 15px rgba(212,175,55,0.7);
            font-family: 'Noto Serif TC', serif;
            letter-spacing: 2px;
        }
        #audio-hint {
            position: absolute; bottom: 20px; left: 20px; color: #fff; cursor: pointer;
            border: 1px solid #d4af37; padding: 12px 18px; border-radius: 8px;
            background: rgba(0,0,0,0.5);
            font-family: 'Noto Serif TC', serif;
            font-size: 18px;
            transition: background 0.3s ease;
            z-index: 10;
        }
        #audio-hint:hover { background: rgba(212,175,55,0.2); }
    </style>
</head>
<body>

<div id="instructions">éµéµ è–èª•å¿«æ¨‚</div>
<div id="audio-hint" onclick="playMusic()">ğŸµ é»æ“Šå•Ÿå‹•éŸ³æ¨‚èˆ‡ç‰¹æ•ˆ</div>

<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import gsap from 'https://cdn.skypack.dev/gsap';

// --- åˆå§‹åŒ–å ´æ™¯ ---
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.toneMapping = THREE.ReinhardToneMapping;
document.body.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);
camera.position.set(0, 10, 25);
controls.target.set(0, 5, 0);
controls.enableDamping = true;

// --- å…‰æº ---
scene.add(new THREE.AmbientLight(0xffffff, 0.6));
const pointLight = new THREE.PointLight(0xffffff, 800);
pointLight.position.set(10, 20, 10);
scene.add(pointLight);

// --- è–èª•æ¨¹ (InstancedMesh) ---
const INSTANCE_COUNT = 4000;
const dummy = new THREE.Object3D();
let currentState = 'tree';

const goldMat = new THREE.MeshStandardMaterial({ color: 0xD4AF37, metalness: 1, roughness: 0.2 });
const sphereGeo = new THREE.SphereGeometry(0.15, 12, 12);
const boxGeo = new THREE.BoxGeometry(0.2, 0.2, 0.2);

const instMesh = new THREE.InstancedMesh(sphereGeo, goldMat, INSTANCE_COUNT);
scene.add(instMesh);

const treePos = [];
const textPos = [];

for (let i = 0; i < INSTANCE_COUNT; i++) {
    const ratio = i / INSTANCE_COUNT;
    const height = ratio * 20;
    const radius = (1 - ratio) * 8;
    const angle = i * 0.5;
    treePos.push(new THREE.Vector3(Math.cos(angle) * radius * (0.8 + Math.random() * 0.4), height - 5, Math.sin(angle) * radius * (0.8 + Math.random() * 0.4)));
    
    let color = new THREE.Color();
    const rand = Math.random();
    if (rand < 0.4) color.setHex(0xD4AF37); // é‡‘
    else if (rand < 0.7) color.setHex(0xAA0000); // ç´…
    else color.setHex(0x004400); // ç¶ 
    instMesh.setColorAt(i, color);
}

// æ–‡å­—åº§æ¨™
const canvas = document.createElement('canvas');
const ctx = canvas.getContext('2d');
canvas.width = 1000; canvas.height = 200;
ctx.fillStyle = 'white';
ctx.font = 'bold 80px "Noto Serif TC", serif';
ctx.textAlign = 'center';
ctx.fillText('éµéµ è–èª•å¿«æ¨‚', 500, 120);
const imgData = ctx.getImageData(0, 0, 1000, 200).data;
const pts = [];
for (let y = 0; y < 200; y += 4) {
    for (let x = 0; x < 1000; x += 4) {
        if (imgData[(y * 1000 + x) * 4] > 128) pts.push(new THREE.Vector3((x - 500) * 0.05, (100 - y) * 0.05 + 5, 0));
    }
}
for (let i = 0; i < INSTANCE_COUNT; i++) textPos.push(pts[i % pts.length] || new THREE.Vector3(0,0,0));

// --- æ¨¹é ‚ ---
const topDecor = new THREE.Mesh(new THREE.OctahedronGeometry(1), new THREE.MeshStandardMaterial({ color: 0xFFFF00, emissive: 0xFFAA00, metalness: 1 }));
topDecor.position.y = 15.5;
scene.add(topDecor);

// --- å¹¾ä½•æ©˜è²“ (Procedural Cat) ---
const catGroup = new THREE.Group();
const orangeMat = new THREE.MeshStandardMaterial({ color: 0xffa500, roughness: 0.8 }); // æ©˜è‰²
const whiteMat = new THREE.MeshStandardMaterial({ color: 0xffffcc, roughness: 0.8 }); // å¥¶æ²¹è‰²

// èº«é«” (æ©¢åœ“çƒ)
const body = new THREE.Mesh(new THREE.SphereGeometry(1, 32, 32), orangeMat);
body.scale.set(1.2, 0.8, 1);
catGroup.add(body);

// é ­
const head = new THREE.Mesh(new THREE.SphereGeometry(0.7, 32, 32), orangeMat);
head.position.set(1, 0.6, 0);
catGroup.add(head);

// è€³æœµ
const earGeo = new THREE.ConeGeometry(0.25, 0.5, 4);
const earL = new THREE.Mesh(earGeo, orangeMat);
earL.position.set(1.2, 1.2, 0.3);
earL.rotation.z = -0.2;
const earR = earL.clone();
earR.position.z = -0.3;
catGroup.add(earL, earR);

// å°¾å·´ (å½æ›²æ„Ÿ)
const tail = new THREE.Mesh(new THREE.CapsuleGeometry(0.15, 1, 4, 8), orangeMat);
tail.position.set(-1.2, 0.5, 0);
tail.rotation.z = Math.PI / 4;
catGroup.add(tail);

// å››è‚¢
const legGeo = new THREE.CapsuleGeometry(0.15, 0.4, 4, 8);
const fl = new THREE.Mesh(legGeo, whiteMat); fl.position.set(0.8, -0.6, 0.4);
const fr = fl.clone(); fr.position.z = -0.4;
const bl = fl.clone(); bl.position.set(-0.6, -0.6, 0.4);
const br = bl.clone(); br.position.z = -0.4;
catGroup.add(fl, fr, bl, br);

catGroup.position.set(8, -4.2, 8); // æ”¾åœ¨æ¨¹æ—
catGroup.scale.set(1.5, 1.5, 1.5);
scene.add(catGroup);

// --- é›ªèŠ± ---
const snowGeo = new THREE.BufferGeometry();
const snowPos = [];
for (let i = 0; i < 5000; i++) snowPos.push((Math.random()-0.5)*100, Math.random()*50, (Math.random()-0.5)*100);
snowGeo.setAttribute('position', new THREE.Float32BufferAttribute(snowPos, 3));
const snowParticles = new THREE.Points(snowGeo, new THREE.PointsMaterial({ color: 0xffffff, size: 0.1, transparent: true, opacity: 0.8 }));
scene.add(snowParticles);

// --- äº¤äº’ ---
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

window.addEventListener('mousedown', (e) => {
    mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);
    
    const intersects = raycaster.intersectObjects(scene.children, true);
    if (intersects.length > 0) {
        let obj = intersects[0].object;
        // åˆ¤æ–·æ˜¯å¦é»æ“Šåˆ°è²“å’ªç¾¤çµ„
        let isCat = false;
        obj.traverseAncestors(anc => { if(anc === catGroup) isCat = true; });

        if (isCat) {
            gsap.to(catGroup.scale, { x: 1.8, y: 1.3, z: 1.8, duration: 0.1, yoyo: true, repeat: 1 });
            gsap.to(catGroup.position, { y: -3.8, duration: 0.1, yoyo: true, repeat: 1 });
            return;
        }
    }
    
    // æ¨¹çš„è®Šæ›
    if (currentState === 'tree') {
        const scat = treePos.map(p => p.clone().add(new THREE.Vector3((Math.random()-0.5)*30, (Math.random()-0.5)*30, (Math.random()-0.5)*30)));
        animateTo(scat); currentState = 'scatter';
    } else if (currentState === 'scatter') {
        animateTo(textPos); currentState = 'text';
    } else {
        animateTo(treePos); currentState = 'tree';
    }
});

function animateTo(targetArray) {
    const startPos = [];
    const mat = new THREE.Matrix4();
    for(let i=0; i<INSTANCE_COUNT; i++) {
        instMesh.getMatrixAt(i, mat);
        startPos.push(new THREE.Vector3().setFromMatrixPosition(mat));
    }
    const obj = { t: 0 };
    gsap.to(obj, { t: 1, duration: 2, ease: "power2.inOut", onUpdate: () => {
        for (let i = 0; i < INSTANCE_COUNT; i++) {
            dummy.position.lerpVectors(startPos[i], targetArray[i], obj.t);
            dummy.updateMatrix();
            instMesh.setMatrixAt(i, dummy.matrix);
        }
        instMesh.instanceMatrix.needsUpdate = true;
    }});
}

// --- éŸ³æ¨‚èˆ‡è‡ªè½‰ ---
const sound = new THREE.Audio(new THREE.AudioListener());
function playMusic() {
    if (!sound.isPlaying) {
        new THREE.AudioLoader().load('https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3', (buf) => {
            sound.setBuffer(buf); sound.setLoop(true); sound.play();
        });
        document.getElementById('audio-hint').style.display = 'none';
    }
}
window.playMusic = playMusic;

function animate() {
    requestAnimationFrame(animate);
    if (currentState === 'tree') { instMesh.rotation.y += 0.005; topDecor.rotation.y += 0.01; }
    
    // é›ªèŠ±å¾ªç’°
    const positions = snowParticles.geometry.attributes.position.array;
    for (let i = 1; i < positions.length; i += 3) {
        positions[i] -= 0.05;
        if (positions[i] < -10) positions[i] = 40;
    }
    snowParticles.geometry.attributes.position.needsUpdate = true;
    
    controls.update();
    renderer.render(scene, camera);
}
animate();

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>

