<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>Merry Christmas to éµéµ</title>
    <style>
        /* è¼‰å…¥æ€æºå®‹é«” */
        @import url('https://fonts.googleapis.com/css2?family=Noto+Serif+TC:wght@700&display=swap');

        body { margin: 0; overflow: hidden; background: #020205; font-family: serif; }
        #instructions {
            position: absolute; top: 40px; width: 100%; text-align: center;
            color: #ffd700; font-size: 32px; pointer-events: none; 
            text-shadow: 0 0 15px rgba(255,215,0,0.7);
            font-family: serif; /* è‹±æ–‡é è¨­ serif */
            z-index: 10;
        }
        #audio-hint {
            position: absolute; bottom: 30px; left: 30px; color: #fff; cursor: pointer;
            border: 1px solid #d4af37; padding: 12px 24px; border-radius: 30px;
            background: rgba(212,175,55,0.2); backdrop-filter: blur(10px);
            font-family: 'Noto Serif TC', serif; z-index: 100;
        }
    </style>
</head>
<body>
    <div id="instructions">Merry Christmas to éµéµ</div>
    <div id="audio-hint" onclick="playMusic()">ğŸµ é»æ“Šå•Ÿå‹•éŸ³æ¨‚èˆ‡ç‰¹æ•ˆ</div>

<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import gsap from 'https://cdn.skypack.dev/gsap';

// --- åˆå§‹åŒ–å ´æ™¯ ---
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
// æé«˜æ›å…‰åº¦è®“é¡è‰²æ›´äº®
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.8; 
document.body.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);
camera.position.set(0, 15, 35);
controls.enableDamping = true;

// --- å¼·åŠ›å…‰æº ---
scene.add(new THREE.AmbientLight(0xffffff, 1.2));
const pointLight = new THREE.PointLight(0xffffff, 1000);
pointLight.position.set(10, 20, 10);
scene.add(pointLight);

// --- è–èª•æ¨¹åƒæ•¸ ---
const COUNT = 10000; // å¢åŠ æ•¸é‡è®“æ¨¹æ›´äº®æ›´èŒ‚å¯†
const dummy = new THREE.Object3D();
let currentState = 'tree';

// é«˜äº®åº¦ PBR æè³ª
const pbrMat = new THREE.MeshStandardMaterial({ 
    metalness: 1, 
    roughness: 0.1,
    emissiveIntensity: 0.3
});

const sphereGeo = new THREE.SphereGeometry(0.12, 12, 12);
const instMesh = new THREE.InstancedMesh(sphereGeo, pbrMat, COUNT);
scene.add(instMesh);

const treePos = [];
const textPos = [];

// ç”Ÿæˆè–èª•æ¨¹åº§æ¨™
for (let i = 0; i < COUNT; i++) {
    const ratio = i / COUNT;
    const height = ratio * 22;
    const radius = (1 - ratio) * 9;
    const angle = i * 0.25;
    
    // æ¨¹ä¸­å¿ƒå¯†é›†ï¼Œé‚Šç·£éš¨æ©Ÿ
    const dist = Math.sqrt(Math.random()) * radius;
    const x = Math.cos(angle) * dist;
    const z = Math.sin(angle) * dist;
    const y = height - 8;
    
    treePos.push(new THREE.Vector3(x, y, z));
    
    let color = new THREE.Color();
    const r = Math.random();
    if (r < 0.6) color.setHex(0xFFD700); // äº®é‡‘
    else if (r < 0.8) color.setHex(0xFF0000); // é®®ç´…
    else color.setHex(0x00FF44); // äº®ç¶ 
    instMesh.setColorAt(i, color);
}

// --- ç”Ÿæˆæ–‡å­—åº§æ¨™ (æ€æºå®‹é«”) ---
function createTextCoords() {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = 1600;
    canvas.height = 400;
    ctx.fillStyle = 'white';
    // è‹±æ–‡ serif, ä¸­æ–‡ Noto Serif TC
    ctx.font = 'bold 85px serif, "Noto Serif TC"';
    ctx.textAlign = 'center';
    ctx.fillText('Merry Christmas to éµéµ', 800, 200);
    
    const imageData = ctx.getImageData(0, 0, 1600, 400).data;
    const points = [];
    for (let y = 0; y < 400; y += 4) {
        for (let x = 0; x < 1600; x += 4) {
            if (imageData[(y * 1600 + x) * 4] > 128) {
                points.push(new THREE.Vector3((x - 800) * 0.05, (200 - y) * 0.05 + 6, 0));
            }
        }
    }
    for (let i = 0; i < COUNT; i++) {
        textPos.push(points[i % points.length].clone());
    }
}
createTextCoords();

// --- æ¨¹é ‚å¤§æ˜Ÿ ---
const topStar = new THREE.Mesh(
    new THREE.OctahedronGeometry(1.5, 0),
    new THREE.MeshStandardMaterial({ color: 0xffff00, emissive: 0xffaa00, emissiveIntensity: 5 })
);
topStar.position.y = 16;
scene.add(topStar);

// --- è£½ä½œå°è²“ (Three.js åŸç”Ÿå¹¾ä½•é«”) ---
const catGroup = new THREE.Group();
const orangeMat = new THREE.MeshStandardMaterial({ color: 0xffa500 });
const whiteMat = new THREE.MeshStandardMaterial({ color: 0xffffff });

// èº«é«” (è† å›Šå½¢)
const body = new THREE.Mesh(new THREE.CapsuleGeometry(0.8, 1.2, 4, 12), orangeMat);
body.rotation.z = Math.PI/2;
catGroup.add(body);

// é ­
const head = new THREE.Mesh(new THREE.SphereGeometry(0.7, 16, 16), orangeMat);
head.position.set(1.2, 0.6, 0);
catGroup.add(head);

// å°¾å·´
const tail = new THREE.Mesh(new THREE.CapsuleGeometry(0.15, 0.8, 4, 8), orangeMat);
tail.position.set(-1.1, 0.5, 0);
tail.rotation.z = Math.PI/4;
catGroup.add(tail);

// æ”¾ç½®åœ¨å³ä¸‹è§’
catGroup.position.set(15, -7.5, 5); 
catGroup.scale.set(2, 2, 2);
scene.add(catGroup);

// --- é›ªèŠ±æ•ˆæœ ---
const snowGeo = new THREE.BufferGeometry();
const snowPos = new Float32Array(5000 * 3);
for(let i=0; i<15000; i++) snowPos[i] = (Math.random()-0.5) * 150;
snowGeo.setAttribute('position', new THREE.BufferAttribute(snowPos, 3));
const snow = new THREE.Points(snowGeo, new THREE.PointsMaterial({ color: 0xffffff, size: 0.15, transparent: true, opacity: 0.8 }));
scene.add(snow);

// --- æ›´æ–°èˆ‡å‹•ç•« ---
function transition(targetArray) {
    const startPositions = [];
    const m = new THREE.Matrix4();
    for(let i=0; i<COUNT; i++) {
        instMesh.getMatrixAt(i, m);
        startPositions.push(new THREE.Vector3().setFromMatrixPosition(m));
    }
    const obj = { t: 0 };
    gsap.to(obj, {
        t: 1, duration: 2, ease: "power3.inOut",
        onUpdate: () => {
            for (let i = 0; i < COUNT; i++) {
                dummy.position.lerpVectors(startPositions[i], targetArray[i], obj.t);
                dummy.updateMatrix();
                instMesh.setMatrixAt(i, dummy.matrix);
            }
            instMesh.instanceMatrix.needsUpdate = true;
        }
    });
}

// --- äº¤äº’ç›£è½ ---
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

window.addEventListener('mousedown', (e) => {
    mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);

    const intersects = raycaster.intersectObjects(scene.children, true);
    if (intersects.length > 0) {
        let isCat = false;
        intersects[0].object.traverseAncestors(obj => { if(obj === catGroup) isCat = true; });

        if (isCat) {
            // å°è²“æ“ å£“å‹•ç•«
            gsap.to(catGroup.scale, { x: 2.3, y: 1.6, z: 2.3, duration: 0.1, yoyo: true, repeat: 1 });
            gsap.to(catGroup.position, { y: -7.0, duration: 0.1, yoyo: true, repeat: 1 });
            return; // é»æ“Šè²“å’ªä¸è§¸ç™¼æ¨¹è®Šæ›
        }
    }

    // è–èª•æ¨¹è®Šæ›
    if (currentState === 'tree') {
        const scat = treePos.map(p => p.clone().add(new THREE.Vector3((Math.random()-0.5)*30, (Math.random()-0.5)*30, (Math.random()-0.5)*30)));
        transition(scat); currentState = 'scatter';
    } else if (currentState === 'scatter') {
        transition(textPos); currentState = 'text';
    } else {
        transition(treePos); currentState = 'tree';
    }
});

// --- æ¸²æŸ“è¿´åœˆ ---
function animate() {
    requestAnimationFrame(animate);
    if (currentState === 'tree') {
        instMesh.rotation.y += 0.005;
        topStar.rotation.y += 0.02;
    }
    
    // é›ªèŠ±ä¸‹è½
    const positions = snow.geometry.attributes.position.array;
    for(let i=1; i<positions.length; i+=3) {
        positions[i] -= 0.1;
        if(positions[i] < -20) positions[i] = 60;
    }
    snow.geometry.attributes.position.needsUpdate = true;

    controls.update();
    renderer.render(scene, camera);
}

// åˆå§‹åŒ–æ¨¹
for (let i = 0; i < COUNT; i++) {
    dummy.position.copy(treePos[i]);
    dummy.updateMatrix();
    instMesh.setMatrixAt(i, dummy.matrix);
}
animate();

// éŸ³æ¨‚æ’­æ”¾
const sound = new THREE.Audio(new THREE.AudioListener());
window.playMusic = () => {
    if (!sound.isPlaying) {
        new THREE.AudioLoader().load('https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3', (buffer) => {
            sound.setBuffer(buffer); sound.setLoop(true); sound.play();
        });
        document.getElementById('audio-hint').style.display = 'none';
    }
}

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>

