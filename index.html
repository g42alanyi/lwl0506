<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>3D Metal Christmas Tree</title>
    <style>
        body { margin: 0; overflow: hidden; background: #050505; font-family: "Times New Roman", serif; }
        #instructions {
            position: absolute; top: 20px; width: 100%; text-align: center;
            color: #d4af37; font-size: 24px; pointer-events: none; text-shadow: 0 0 10px rgba(212,175,55,0.5);
        }
        #audio-hint {
            position: absolute; bottom: 20px; left: 20px; color: #fff; cursor: pointer;
            border: 1px solid #fff; padding: 10px; border-radius: 5px;
        }
    </style>
</head>
<body>

<div id="instructions">Merry Christmas to éµéµ</div>
<div id="audio-hint" onclick="playMusic()">ğŸµ é»æ“Šå•Ÿå‹•éŸ³æ¨‚èˆ‡ç‰¹æ•ˆ</div>

<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import gsap from 'https://cdn.skypack.dev/gsap';

// --- åˆå§‹åŒ–å ´æ™¯ ---
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
renderer.toneMapping = THREE.ReinhardToneMapping;
document.body.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);
camera.position.set(0, 15, 30);

// --- å…‰æº (PBR é—œéµ) ---
const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
scene.add(ambientLight);

const pointLight = new THREE.PointLight(0xffffff, 500);
pointLight.position.set(10, 20, 10);
scene.add(pointLight);

const goldLight = new THREE.PointLight(0xd4af37, 300);
goldLight.position.set(-10, 5, -10);
scene.add(goldLight);

// --- åƒæ•¸è¨­ç½® ---
const COUNT = 4000; // ç¸½å¹¾ä½•é«”æ•¸é‡
const dummy = new THREE.Object3D();
let currentState = 'tree'; // tree, scatter, text

// æè³ªå®šç¾©
const goldMat = new THREE.MeshStandardMaterial({ color: 0xD4AF37, metalness: 1, roughness: 0.2 });
const redMat = new THREE.MeshStandardMaterial({ color: 0xAA0000, metalness: 0.8, roughness: 0.3 });
const greenMat = new THREE.MeshStandardMaterial({ color: 0x003300, metalness: 0.7, roughness: 0.4 });

// --- å‰µå»º InstancedMesh ---
// æˆ‘å€‘æ··åˆçƒé«”å’Œç«‹æ–¹é«”ï¼Œé€™è£¡ç°¡åŒ–ä½¿ç”¨ä¸€å€‹ Meshï¼Œæˆ–å¯å‰µå»ºå…©å€‹å–®ç¨çš„ Instance
const sphereGeo = new THREE.SphereGeometry(0.15, 12, 12);
const boxGeo = new THREE.BoxGeometry(0.2, 0.2, 0.2);

const instMesh = new THREE.InstancedMesh(sphereGeo, goldMat, COUNT);
scene.add(instMesh);

// å­˜å„²ä½ç½®æ•¸æ“š
const treePos = [];
const textPos = [];
const scatterPos = [];

// --- ç”Ÿæˆè–èª•æ¨¹åº§æ¨™ ---
for (let i = 0; i < COUNT; i++) {
    const ratio = i / COUNT;
    const height = ratio * 20;
    const radius = (1 - ratio) * 8;
    const angle = i * 0.5;
    
    const x = Math.cos(angle) * radius * Math.random();
    const z = Math.sin(angle) * radius * Math.random();
    const y = height - 5;
    
    treePos.push(new THREE.Vector3(x, y, z));
    
    // è¨­ç½®åˆå§‹é¡è‰²
    let color = new THREE.Color();
    if (i % 3 === 0) color.setHex(0xD4AF37); // é‡‘
    else if (i % 3 === 1) color.setHex(0xAA0000); // ç´…
    else color.setHex(0x004400); // ç¶ 
    instMesh.setColorAt(i, color);
}

// --- ç”Ÿæˆæ–‡å­—åº§æ¨™ (Canvas æ¡æ¨£) ---
function createTextCoords() {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = 1000;
    canvas.height = 200;
    ctx.fillStyle = 'white';
    ctx.font = 'bold 60px serif';
    ctx.textAlign = 'center';
    ctx.fillText('Merry Christmas to éµéµ', 500, 100);
    
    const imageData = ctx.getImageData(0, 0, 1000, 200).data;
    const points = [];
    for (let y = 0; y < 200; y += 4) {
        for (let x = 0; x < 1000; x += 4) {
            if (imageData[(y * 1000 + x) * 4] > 128) {
                points.push(new THREE.Vector3((x - 500) * 0.05, (100 - y) * 0.05 + 5, 0));
            }
        }
    }
    // å¡«å……åˆ° COUNT æ•¸é‡
    for (let i = 0; i < COUNT; i++) {
        textPos.push(points[i % points.length] || new THREE.Vector3(0,0,0));
    }
}
createTextCoords();

// --- æ¨¹é ‚è£é£¾ (å…«é¢é«”) ---
const topGeo = new THREE.OctahedronGeometry(1);
const topMat = new THREE.MeshStandardMaterial({ color: 0xFFFF00, emissive: 0xFFAA00, metalness: 1 });
const topDecor = new THREE.Mesh(topGeo, topMat);
topDecor.position.y = 15.5;
scene.add(topDecor);

// --- å‹•æ…‹æ›´æ–°å‡½æ•¸ ---
function updateMesh(positions) {
    for (let i = 0; i < COUNT; i++) {
        const target = positions[i];
        dummy.position.copy(target);
        dummy.updateMatrix();
        instMesh.setMatrixAt(i, dummy.matrix);
    }
    instMesh.instanceMatrix.needsUpdate = true;
}

// åˆå§‹é¡¯ç¤ºæ¨¹
updateMesh(treePos);

// --- äº¤äº’é‚è¼¯ ---
window.addEventListener('click', () => {
    if (currentState === 'tree') {
        // æ“´æ•£
        const scatter = treePos.map(p => p.clone().add(new THREE.Vector3(
            (Math.random() - 0.5) * 20,
            (Math.random() - 0.5) * 20,
            (Math.random() - 0.5) * 20
        )));
        animateTo(scatter);
        currentState = 'scatter';
    } else if (currentState === 'scatter') {
        // æ‹¼æˆæ–‡å­—
        animateTo(textPos);
        currentState = 'text';
    } else {
        // æ¢å¾©
        animateTo(treePos);
        currentState = 'tree';
    }
});

function animateTo(targetArray) {
    const obj = { t: 0 };
    const startPos = [];
    const currentMatrix = new THREE.Matrix4();
    
    for(let i=0; i<COUNT; i++) {
        instMesh.getMatrixAt(i, currentMatrix);
        let pos = new THREE.Vector3();
        pos.setFromMatrixPosition(currentMatrix);
        startPos.push(pos);
    }

    gsap.to(obj, {
        t: 1,
        duration: 2,
        ease: "power2.inOut",
        onUpdate: () => {
            for (let i = 0; i < COUNT; i++) {
                const lerpedPos = new THREE.Vector3().lerpVectors(startPos[i], targetArray[i], obj.t);
                dummy.position.copy(lerpedPos);
                // å¢åŠ ä¸€é»éš¨æ©Ÿæ—‹è½‰å¢åŠ é‡‘å±¬åå…‰æ„Ÿ
                dummy.rotation.x += 0.01;
                dummy.updateMatrix();
                instMesh.setMatrixAt(i, dummy.matrix);
            }
            instMesh.instanceMatrix.needsUpdate = true;
        }
    });
}

// --- éŸ³æ¨‚è™•ç† ---
const listener = new THREE.AudioListener();
camera.add(listener);
const sound = new THREE.Audio(listener);
const audioLoader = new THREE.AudioLoader();

// é€™è£¡å»ºè­°ä½¿ç”¨ä¸€å€‹å…¬é–‹çš„è–èª•æ­Œæ›²é€£çµï¼Œæˆ–æ˜¯ä½ æœ¬åœ°çš„ mp3
function playMusic() {
    if (!sound.isPlaying) {
        audioLoader.load('https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3', function(buffer) {
            sound.setBuffer(buffer);
            sound.setLoop(true);
            sound.setVolume(0.5);
            sound.play();
        });
        document.getElementById('audio-hint').style.display = 'none';
    }
}

// --- æ¸²æŸ“è¿´åœˆ ---
function animate() {
    requestAnimationFrame(animate);
    
    // è–èª•æ¨¹è‡ªè½‰
    if (currentState === 'tree') {
        instMesh.rotation.y += 0.005;
        topDecor.rotation.y += 0.01;
    } else {
        instMesh.rotation.y *= 0.95; // åœæ­¢æ—‹è½‰
    }
    
    controls.update();
    renderer.render(scene, camera);
}
animate();

// è¦–çª—ç¸®æ”¾é©æ‡‰
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

</script>
</body>
</html>

