<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>Merry Christmas to éµéµ</title>
    <style>
        @font-face {
            font-family: 'Noto Serif TC';
            src: url('https://fonts.gstatic.com/s/notoseriftc/v19/XLYgR5vtWpzzTfPR--iJ_y2W4k_B3N-Y76kP_D_A7_N.woff2') format('woff2');
        }
        body { margin: 0; overflow: hidden; background: #020205; }
        #instructions {
            position: absolute; top: 40px; width: 100%; text-align: center;
            color: #f1d37e; font-size: clamp(24px, 5vw, 40px); pointer-events: none; 
            text-shadow: 0 0 20px rgba(212,175,55,0.8);
            font-family: 'Times New Roman', 'Noto Serif TC', serif;
            letter-spacing: 2px;
            z-index: 10;
        }
        #audio-hint {
            position: absolute; bottom: 30px; left: 30px; color: #fff; cursor: pointer;
            border: 1px solid #d4af37; padding: 12px 24px; border-radius: 30px;
            background: rgba(212,175,55,0.1);
            font-family: 'Noto Serif TC', serif;
            backdrop-filter: blur(8px);
            z-index: 100;
        }
    </style>
</head>
<body>

<div id="instructions">Merry Christmas to éµéµ</div>
<div id="audio-hint" onclick="playMusic()">ğŸµ é–‹å•ŸéŸ³æ¨‚èˆ‡å¥‡è¹Ÿ</div>

<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import gsap from 'https://cdn.skypack.dev/gsap';

// --- å ´æ™¯è¨­ç½® ---
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.5; // æé«˜æ›å…‰è®“ç•«é¢æ›´äº®
document.body.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);
camera.position.set(0, 12, 35);
controls.target.set(0, 4, 0);
controls.enableDamping = true;

// --- ç‡ˆå…‰ (æ¥µè‡´äº®åº¦) ---
scene.add(new THREE.AmbientLight(0xffffff, 0.8)); // åŸºç¤ç’°å¢ƒå…‰èª¿é«˜

const topLight = new THREE.SpotLight(0xffffff, 2000);
topLight.position.set(0, 30, 10);
topLight.angle = 0.6;
scene.add(topLight);

const rimLight = new THREE.PointLight(0xffffff, 1000); // èƒŒå…‰å¢åŠ è¼ªå»“æ„Ÿ
rimLight.position.set(0, 10, -20);
scene.add(rimLight);

const goldLight = new THREE.PointLight(0xffd700, 800);
goldLight.position.set(-15, 5, 10);
scene.add(goldLight);

// --- è–èª•æ¨¹ (15,000 ç²’å­) ---
const COUNT = 15000;
const dummy = new THREE.Object3D();
let currentState = 'tree';

const pbrMat = new THREE.MeshStandardMaterial({ 
    metalness: 1.0, 
    roughness: 0.1, 
    emissive: 0x221100, // å¾®å¼±è‡ªç™¼å…‰å¢åŠ äº®åº¦
    emissiveIntensity: 0.5
});

const sphereGeo = new THREE.SphereGeometry(0.12, 8, 8);
const boxGeo = new THREE.BoxGeometry(0.16, 0.16, 0.16);

const instSpheres = new THREE.InstancedMesh(sphereGeo, pbrMat, COUNT / 2);
const instBoxes = new THREE.InstancedMesh(boxGeo, pbrMat, COUNT / 2);
scene.add(instSpheres, instBoxes);

const treePos = [];
const textPos = [];

// ç”Ÿæˆæ¨¹çµæ§‹
for (let i = 0; i < COUNT; i++) {
    const ratio = i / COUNT;
    const height = ratio * 22;
    const radius = (1 - ratio) * 9;
    const angle = i * 0.2;
    const dist = Math.sqrt(Math.random()) * radius;
    const pos = new THREE.Vector3(Math.cos(angle) * dist, height - 8, Math.sin(angle) * dist);
    treePos.push(pos);

    const color = new THREE.Color();
    const r = Math.random();
    if (r < 0.6) color.setHex(0xFFD700); // æ˜äº®é‡‘
    else if (r < 0.8) color.setHex(0xFF0000); // é®®ç´…
    else color.setHex(0x00FF44); // é®®ç¶ 
    
    const target = (i < COUNT/2) ? instSpheres : instBoxes;
    target.setColorAt(i % (COUNT/2), color);
}

// --- æ–‡å­—åº§æ¨™ (Serif Font) ---
function initText() {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = 1600; canvas.height = 400;
    ctx.fillStyle = 'white';
    // å„ªå…ˆä½¿ç”¨ Serif å­—é«”
    ctx.font = 'bold 100px "Times New Roman", "Noto Serif TC", serif';
    ctx.textAlign = 'center';
    ctx.fillText('Merry Christmas to éµéµ', 800, 200);
    
    const data = ctx.getImageData(0, 0, 1600, 400).data;
    const pts = [];
    for (let y = 0; y < 400; y += 4) {
        for (let x = 0; x < 1600; x += 4) {
            if (data[(y * 1600 + x) * 4] > 128) {
                pts.push(new THREE.Vector3((x - 800) * 0.045, (200 - y) * 0.045 + 5, 0));
            }
        }
    }
    for (let i = 0; i < COUNT; i++) textPos.push(pts[i % pts.length].clone());
}
initText();

// --- æ¨¹é ‚ ---
const topStar = new THREE.Mesh(
    new THREE.OctahedronGeometry(1.5, 0), 
    new THREE.MeshStandardMaterial({ color: 0xffff00, emissive: 0xffaa00, emissiveIntensity: 5 })
);
topStar.position.y = 15;
scene.add(topStar);

// --- æ©˜è²“ (ç§»è‡³å³ä¸‹è§’ï¼Œé¿å…èª¤è§¸) ---
const catGroup = new THREE.Group();
const orangeMat = new THREE.MeshStandardMaterial({ color: 0xff9900 });
const catBody = new THREE.Mesh(new THREE.SphereGeometry(1, 16, 16), orangeMat);
catBody.scale.set(1.4, 0.9, 1);
catGroup.add(catBody);
const catHead = new THREE.Mesh(new THREE.SphereGeometry(0.7, 16, 16), orangeMat);
catHead.position.set(1.2, 0.6, 0);
catGroup.add(catHead);
// è¨­ç½®åœ¨ç•«é¢å³å´è¼ƒé è™•
catGroup.position.set(18, -7, 10); 
catGroup.scale.set(2, 2, 2);
scene.add(catGroup);

// --- é›ªèŠ± ---
const snowGeo = new THREE.BufferGeometry();
const snowPos = new Float32Array(8000 * 3);
for(let i=0; i<24000; i++) snowPos[i] = (Math.random()-0.5)*120;
snowGeo.setAttribute('position', new THREE.BufferAttribute(snowPos, 3));
const snow = new THREE.Points(snowGeo, new THREE.PointsMaterial({ color: 0xffffff, size: 0.1, transparent: true, opacity: 0.5 }));
scene.add(snow);

// --- å‹•æ…‹å‹•ç•« ---
function transition(targetArray) {
    const startPositions = [];
    [instSpheres, instBoxes].forEach(mesh => {
        const m = new THREE.Matrix4();
        for(let i=0; i<COUNT/2; i++) {
            mesh.getMatrixAt(i, m);
            startPositions.push(new THREE.Vector3().setFromMatrixPosition(m));
        }
    });

    const obj = { t: 0 };
    gsap.to(obj, {
        t: 1, duration: 2, ease: "power3.inOut",
        onUpdate: () => {
            for (let i = 0; i < COUNT; i++) {
                const mesh = i < COUNT/2 ? instSpheres : instBoxes;
                const idx = i % (COUNT/2);
                dummy.position.lerpVectors(startPositions[i], targetArray[i], obj.t);
                dummy.updateMatrix();
                mesh.setMatrixAt(idx, dummy.matrix);
            }
            instSpheres.instanceMatrix.needsUpdate = true;
            instBoxes.instanceMatrix.needsUpdate = true;
        }
    });
}

// --- é»æ“Šç›£è½ ---
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

window.addEventListener('mousedown', (e) => {
    mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);

    const intersects = raycaster.intersectObjects(scene.children, true);
    if (intersects.length > 0) {
        let hitCat = false;
        intersects[0].object.traverseAncestors(a => { if(a === catGroup) hitCat = true; });
        
        if (hitCat) {
            gsap.to(catGroup.scale, { x: 2.2, y: 1.8, z: 2.2, duration: 0.1, yoyo: true, repeat: 1 });
            return;
        }
    }

    // ç‹€æ…‹å¾ªç’°
    if (currentState === 'tree') {
        const scat = treePos.map(p => p.clone().add(new THREE.Vector3((Math.random()-0.5)*30, (Math.random()-0.5)*30, (Math.random()-0.5)*30)));
        transition(scat); currentState = 'scatter';
    } else if (currentState === 'scatter') {
        transition(textPos); currentState = 'text';
    } else {
        transition(treePos); currentState = 'tree';
    }
});

// --- æ¸²æŸ“ ---
function animate() {
    requestAnimationFrame(animate);
    if (currentState === 'tree') {
        instSpheres.rotation.y += 0.005;
        instBoxes.rotation.y += 0.005;
    }
    
    // é›ªèŠ±ä¸‹è½
    const pos = snow.geometry.attributes.position.array;
    for(let i=1; i<pos.length; i+=3) {
        pos[i] -= 0.05;
        if(pos[i] < -20) pos[i] = 50;
    }
    snow.geometry.attributes.position.needsUpdate = true;

    controls.update();
    renderer.render(scene, camera);
}

// åˆå§‹åŒ–
for (let i = 0; i < COUNT; i++) {
    const mesh = i < COUNT/2 ? instSpheres : instBoxes;
    dummy.position.copy(treePos[i]);
    dummy.updateMatrix();
    mesh.setMatrixAt(i % (COUNT/2), dummy.matrix);
}
animate();

// éŸ³æ¨‚æ’­æ”¾
const sound = new THREE.Audio(new THREE.AudioListener());
window.playMusic = () => {
    if (!sound.isPlaying) {
        new THREE.AudioLoader().load('https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3', (b) => {
            sound.setBuffer(b); sound.setLoop(true); sound.play();
        });
        document.getElementById('audio-hint').style.display = 'none';
    }
}

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>

